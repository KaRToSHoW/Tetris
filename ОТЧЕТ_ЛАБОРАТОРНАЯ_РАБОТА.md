# Отчет по лабораторной работе
## Управление ресурсами мобильного приложения с использованием React Hooks и Supabase

### Введение

**Цель работы:** Научиться эффективно управлять ресурсами мобильного приложения, используя современные паттерны React Hooks и облачную базу данных Supabase для демонстрации практического управления данными.

**Задачи:**
1. Интегрировать Supabase как основную систему управления данными
2. Создать сервисы для работы с облачной базой данных
3. Разработать кастомные React Hooks для управления состоянием и ресурсами
4. Продемонстрировать различные паттерны использования хуков React
5. Реализовать практические компоненты для управления игровыми данными

---

### 1. Технологический стек

**Основные технологии:**
- React Native с Expo
- TypeScript для типизации
- Supabase - облачная PostgreSQL база данных
- React Hooks для управления состоянием

**React Hooks, использованные в проекте:**
- `useState` - базовое управление локальным состоянием
- `useEffect` - эффекты жизненного цикла и побочные действия
- `useCallback` - мемоизация функций для оптимизации
- `useMemo` - мемоизация вычислений
- `useRef` - ссылки на DOM элементы и мутабельные значения
- `useReducer` - сложное управление состоянием с редьюсерами

---

### 2. Архитектура управления ресурсами

#### 2.1. Настройка Supabase

Создан клиент Supabase с типизацией для основных сущностей:

```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://igzogtxlmfirwimqnvqa.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Типы для таблиц базы данных
export interface GameRecord {
  id?: number;
  player_name: string;
  score: number;
  level: number;
  lines_cleared: number;
  time_played: number;
  created_at?: string;
}

export interface GameSettings {
  id?: number;
  player_name: string;
  control_mode: 'buttons' | 'swipes';
  show_grid: boolean;
  sound_enabled: boolean;
  difficulty: 'easy' | 'medium' | 'hard';
  created_at?: string;
  updated_at?: string;
}

export interface PlayerStats {
  id?: number;
  player_name: string;
  total_games: number;
  total_score: number;
  best_score: number;
  total_lines_cleared: number;
  avg_time_per_game: number;
  created_at?: string;
  updated_at?: string;
}
```

**Комментарии к коду:**
- Supabase клиент настроен с публичным анонимным ключом
- Определены TypeScript интерфейсы для всех сущностей базы данных
- Используется строгая типизация для безопасности работы с данными

#### 2.2. Сервис для работы с игровыми данными

Создан класс `GameService` для инкапсуляции всей логики работы с Supabase:

```typescript
// src/services/gameService.ts
export class GameService {
  /**
   * Сохранение результата игры
   * Управляет ресурсом игровых рекордов
   */
  static async saveGameRecord(record: Omit<GameRecord, 'id' | 'created_at'>): Promise<GameRecord | null> {
    try {
      console.log('Saving game record:', record);
      
      const { data, error } = await supabase
        .from('game_records')
        .insert([record])
        .select()
        .single();

      if (error) {
        console.error('Error saving game record:', error);
        throw error;
      }

      console.log('Game record saved successfully:', data);
      return data;
    } catch (error) {
      console.error('Failed to save game record:', error);
      return null;
    }
  }

  /**
   * Получение лучших результатов
   * Демонстрирует загрузку и кэширование данных
   */
  static async getTopScores(limit: number = 10): Promise<GameRecord[]> {
    try {
      console.log('Fetching top scores, limit:', limit);
      
      const { data, error } = await supabase
        .from('game_records')
        .select('*')
        .order('score', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('Error fetching top scores:', error);
        throw error;
      }

      console.log('Top scores fetched successfully:', data?.length, 'records');
      return data || [];
    } catch (error) {
      console.error('Failed to fetch top scores:', error);
      return [];
    }
  }

  /**
   * Обновление статистики игрока
   * Управление агрегированными данными
   */
  static async updatePlayerStats(playerName: string, gameData: {
    score: number;
    linesCleared: number;
    timePlayed: number;
  }): Promise<PlayerStats | null> {
    try {
      // Получаем текущую статистику
      const { data: currentStats } = await supabase
        .from('player_stats')
        .select('*')
        .eq('player_name', playerName)
        .single();

      const newStats = currentStats 
        ? {
            // Обновляем существующую статистику
            player_name: playerName,
            total_games: currentStats.total_games + 1,
            total_score: currentStats.total_score + gameData.score,
            best_score: Math.max(currentStats.best_score, gameData.score),
            total_lines_cleared: currentStats.total_lines_cleared + gameData.linesCleared,
            avg_time_per_game: Math.round(
              (currentStats.avg_time_per_game * currentStats.total_games + gameData.timePlayed) / 
              (currentStats.total_games + 1)
            ),
          }
        : {
            // Создаем новую статистику
            player_name: playerName,
            total_games: 1,
            total_score: gameData.score,
            best_score: gameData.score,
            total_lines_cleared: gameData.linesCleared,
            avg_time_per_game: gameData.timePlayed,
          };

      // Сохраняем или обновляем данные...
      
      return result;
    } catch (error) {
      console.error('Failed to update player stats:', error);
      return null;
    }
  }
}
```

**Ключевые особенности сервиса:**
- Инкапсулирует всю логику работы с базой данных
- Обеспечивает обработку ошибок на уровне сервиса
- Использует TypeScript для строгой типизации
- Логирует операции для отладки
- Реализует сложную логику агрегации данных (статистика игрока)

---

### 3. Кастомные React Hooks

#### 3.1. Хуки для работы с игровыми данными

Созданы специализированные хуки для управления различными типами ресурсов:

```typescript
// src/hooks/useGameData.ts

/**
 * Хук для управления игровыми рекордами
 * Демонстрирует использование useState, useEffect, useCallback для управления данными
 */
export function useGameRecords(playerName?: string) {
  const [records, setRecords] = useState<GameRecord[]>([]);
  const [topScores, setTopScores] = useState<GameRecord[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // useCallback для оптимизации функций
  const loadTopScores = useCallback(async (limit: number = 10) => {
    setIsLoading(true);
    setError(null);
    try {
      const scores = await GameService.getTopScores(limit);
      setTopScores(scores);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load top scores');
    } finally {
      setIsLoading(false);
    }
  }, []);

  const saveRecord = useCallback(async (record: Omit<GameRecord, 'id' | 'created_at'>) => {
    setError(null);
    try {
      const savedRecord = await GameService.saveGameRecord(record);
      if (savedRecord) {
        // Обновляем локальные данные
        setRecords(prev => [savedRecord, ...prev]);
        // Если это топ результат, обновляем топ-лист
        if (topScores.length === 0 || savedRecord.score > topScores[topScores.length - 1]?.score) {
          await loadTopScores();
        }
        return savedRecord;
      }
      return null;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save record');
      return null;
    }
  }, [topScores, loadTopScores]);

  // useEffect для автоматической загрузки данных
  useEffect(() => {
    loadTopScores();
  }, [loadTopScores]);

  useEffect(() => {
    if (playerName) {
      loadPlayerRecords(playerName);
    }
  }, [playerName, loadPlayerRecords]);

  // useMemo для оптимизации вычислений
  const playerBestScore = useMemo(() => {
    if (records.length === 0) return 0;
    return Math.max(...records.map(record => record.score));
  }, [records]);

  return {
    records,
    topScores,
    isLoading,
    error,
    playerBestScore,
    saveRecord,
    refresh: () => {
      loadTopScores();
      if (playerName) {
        loadPlayerRecords(playerName);
      }
    },
  };
}
```

**Демонстрируемые концепции:**
- **useState**: управление состоянием данных, загрузки и ошибок
- **useEffect**: автоматическая загрузка данных при изменении зависимостей
- **useCallback**: оптимизация функций для предотвращения лишних рендеров
- **useMemo**: кэширование вычислений (лучший счет игрока)

#### 3.2. Продвинутые хуки для управления ресурсами

Создан универсальный хук для загрузки ресурсов с автоматическими повторными попытками:

```typescript
// src/hooks/useResourceManager.ts

/**
 * Хук для управления состоянием загрузки ресурсов
 * Демонстрирует useReducer для сложного управления состоянием
 */

interface ResourceState<T> {
  data: T | null;
  isLoading: boolean;
  error: string | null;
  lastUpdated: Date | null;
  retryCount: number;
}

type ResourceAction<T> = 
  | { type: 'LOADING_START' }
  | { type: 'LOADING_SUCCESS'; payload: T }
  | { type: 'LOADING_ERROR'; payload: string }
  | { type: 'RETRY' }
  | { type: 'RESET' };

function resourceReducer<T>(state: ResourceState<T>, action: ResourceAction<T>): ResourceState<T> {
  switch (action.type) {
    case 'LOADING_START':
      return { ...state, isLoading: true, error: null };
    case 'LOADING_SUCCESS':
      return {
        ...state,
        isLoading: false,
        data: action.payload,
        error: null,
        lastUpdated: new Date(),
        retryCount: 0,
      };
    case 'LOADING_ERROR':
      return {
        ...state,
        isLoading: false,
        error: action.payload,
        retryCount: state.retryCount + 1,
      };
    // ... другие случаи
    default:
      return state;
  }
}

export function useResourceLoader<T>(
  loadFunction: () => Promise<T>,
  options: {
    autoLoad?: boolean;
    retryAttempts?: number;
    retryDelay?: number;
    cacheTimeout?: number;
  } = {}
) {
  const [state, dispatch] = useReducer(resourceReducer<T>, {
    data: null,
    isLoading: false,
    error: null,
    lastUpdated: null,
    retryCount: 0,
  });

  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Функция загрузки с обработкой ошибок и повторными попытками
  const load = useCallback(async (force: boolean = false) => {
    // Проверяем кэш
    if (!force && state.data && state.lastUpdated) {
      const timeSinceUpdate = Date.now() - state.lastUpdated.getTime();
      if (timeSinceUpdate < cacheTimeout) {
        console.log('Using cached data');
        return;
      }
    }

    dispatch({ type: 'LOADING_START' });

    try {
      const data = await loadFunction();
      dispatch({ type: 'LOADING_SUCCESS', payload: data });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      dispatch({ type: 'LOADING_ERROR', payload: errorMessage });

      // Автоматическая повторная попытка
      if (state.retryCount < retryAttempts) {
        retryTimeoutRef.current = setTimeout(() => {
          dispatch({ type: 'RETRY' });
          load(force);
        }, retryDelay * (state.retryCount + 1));
      }
    }
  }, [state.data, state.lastUpdated, state.retryCount, /* ... */]);

  return {
    ...state,
    load,
    refresh: () => load(true),
    reset: () => dispatch({ type: 'RESET' }),
  };
}
```

**Продвинутые концепции:**
- **useReducer**: управление сложным состоянием с множественными переходами
- **useRef**: хранение мутабельных значений (таймеры)
- **Кэширование**: проверка актуальности данных по времени
- **Автоматические повторы**: интеллектуальная обработка ошибок

---

### 4. Практические компоненты

#### 4.1. Компонент статистики игрока

Создан полнофункциональный компонент для отображения статистики:

```typescript
// src/components/GameStats.tsx

const GameStats: React.FC<GameStatsProps> = ({ playerName, onClose }) => {
  const [selectedTab, setSelectedTab] = useState<'personal' | 'global'>('personal');
  
  // Использование кастомных хуков для управления данными
  const { 
    stats, 
    gameAnalytics, 
    playerRank, 
    isLoading: statsLoading,
    error: statsError,
    refresh: refreshStats 
  } = usePlayerStats(playerName);

  const { 
    records, 
    topScores, 
    isLoading: recordsLoading,
    error: recordsError,
    playerBestScore,
    playerAverageScore,
    refresh: refreshRecords 
  } = useGameRecords(playerName);

  // Демонстрация useResourceLoader для загрузки аналитики
  const {
    data: analytics,
    isLoading: analyticsLoading,
    error: analyticsError,
    refresh: refreshAnalytics,
    isStale
  } = useResourceLoader(
    () => GameService.getGameAnalytics(),
    {
      autoLoad: true,
      retryAttempts: 3,
      cacheTimeout: 2 * 60 * 1000, // 2 минуты кэш
    }
  );

  // Объединенное состояние загрузки
  const isLoading = statsLoading || recordsLoading || analyticsLoading;
  
  return (
    <View style={styles.container}>
      {/* Интерфейс с табами для переключения между личной и глобальной статистикой */}
      {/* Индикаторы загрузки и ошибок */}
      {/* Автоматическое обновление данных */}
    </View>
  );
};
```

#### 4.2. Компонент настроек с автосохранением

```typescript
// src/components/PlayerSettings.tsx

const PlayerSettings: React.FC<PlayerSettingsProps> = ({
  playerName,
  onPlayerNameChange,
  onClose,
}) => {
  const [showSaveIndicator, setShowSaveIndicator] = useState(false);

  // Использование кастомного хука для управления настройками
  const {
    settings,
    isLoading,
    error,
    hasChanges,
    updateSettings,
    saveSettings,
  } = usePlayerSettings(playerName);

  // Дебаунсинг автосохранения настроек
  const debouncedSave = useDebounceCallback(async () => {
    if (hasChanges) {
      setShowSaveIndicator(true);
      const success = await saveSettings();
      if (success) {
        setShowSaveIndicator(false);
      }
    }
  }, 2000); // Автосохранение через 2 секунды

  // Эффект для автосохранения
  useEffect(() => {
    if (hasChanges) {
      debouncedSave();
    }
  }, [hasChanges, debouncedSave]);

  return (
    <View style={styles.container}>
      {/* Формы настроек с автосохранением */}
      {/* Индикаторы состояния сохранения */}
    </View>
  );
};
```

---

### 5. Демонстрация управления ресурсами

#### 5.1. Интеграция в основное приложение

Обновлен главный компонент App.tsx для демонстрации полного цикла управления ресурсами:

```typescript
// App.tsx
export default function App() {
  const [playerName, setPlayerName] = useState('Игрок');
  
  // Кастомные хуки для управления ресурсами через Supabase
  const {
    records,
    saveRecord,
    isLoading: recordsLoading,
    error: recordsError
  } = useGameRecords(playerName);
  
  const {
    updateStats,
    isLoading: statsLoading,
    error: statsError
  } = usePlayerStats(playerName);

  // Обработчик окончания игры с сохранением в Supabase
  const handleGameOver = useCallback(async (score: number, lines: number, level: number, gameTimeMs: number = 0) => {
    try {
      // Сохраняем рекорд в Supabase
      await saveRecord({
        player_name: playerName,
        score,
        level,
        lines_cleared: lines,
        time_played: Math.round(gameTimeMs / 1000),
      });
      
      // Обновляем статистику игрока
      await updateStats({
        score,
        linesCleared: lines,
        timePlayed: Math.round(gameTimeMs / 1000),
      });
      
      console.log('Game data saved to Supabase');
    } catch (error) {
      console.error('Error saving game data:', error);
    }
  }, [playerName, saveRecord, updateStats]);
}
```

#### 5.2. Жизненный цикл управления ресурсами

**Этапы работы с ресурсами:**

1. **Инициализация**: Автоматическая загрузка данных при монтировании компонентов
2. **Кэширование**: Сохранение данных в памяти с проверкой актуальности
3. **Оптимистичные обновления**: Немедленное обновление UI с последующей синхронизацией
4. **Обработка ошибок**: Автоматические повторы и откат к кэшированным данным
5. **Очистка**: Автоматическая очистка таймеров и подписок при размонтировании

---

### 6. Выводы и результаты

#### 6.1. Достигнутые результаты

1. **Интеграция Supabase**: Успешно настроена облачная база данных с типизированными моделями данных
2. **Кастомные хуки**: Созданы переиспользуемые хуки для различных паттернов работы с данными
3. **Оптимизация производительности**: Использованы техники мемоизации и кэширования
4. **Обработка ошибок**: Реализована надежная система обработки ошибок на всех уровнях
5. **UX оптимизация**: Добавлены индикаторы загрузки, автосохранение и оптимистичные обновления

#### 6.2. Использованные React Hooks и их назначение

| Hook | Назначение | Примеры использования |
|------|------------|----------------------|
| `useState` | Локальное состояние компонентов | Управление формами, UI состояниями |
| `useEffect` | Побочные эффекты и жизненный цикл | Загрузка данных, подписки, очистка |
| `useCallback` | Мемоизация функций | Оптимизация производительности |
| `useMemo` | Мемоизация вычислений | Кэширование дорогих расчетов |
| `useRef` | Ссылки и мутабельные значения | Таймеры, DOM ссылки |
| `useReducer` | Сложное управление состоянием | Состояние с множественными переходами |

#### 6.3. Архитектурные преимущества

1. **Разделение ответственности**: Четкое разделение между UI, логикой и данными
2. **Переиспользуемость**: Кастомные хуки могут использоваться в разных компонентах
3. **Тестируемость**: Логика изолирована в хуках и сервисах
4. **Масштабируемость**: Архитектура позволяет легко добавлять новые функции
5. **TypeScript интеграция**: Строгая типизация на всех уровнях

#### 6.4. Практическая ценность

Реализованное решение демонстрирует:
- Современные паттерны разработки React Native приложений
- Эффективные техники управления состоянием и ресурсами
- Интеграцию с современными облачными сервисами
- Оптимизацию производительности и пользовательского опыта

Данный подход может быть применен в реальных проектах для создания надежных и масштабируемых мобильных приложений с эффективным управлением ресурсами.

---

### 7. Файловая структура проекта

```
src/
├── lib/
│   └── supabase.ts          # Конфигурация Supabase клиента
├── services/
│   └── gameService.ts       # Сервис для работы с игровыми данными
├── hooks/
│   ├── useGameData.ts       # Хуки для игровых данных
│   └── useResourceManager.ts # Продвинутые хуки управления ресурсами
├── components/
│   ├── GameStats.tsx        # Компонент статистики
│   ├── PlayerSettings.tsx   # Компонент настроек игрока
│   └── ...                  # Другие игровые компоненты
└── types/
    └── app.ts              # TypeScript типы
```

Данная архитектура обеспечивает четкое разделение ответственности и легкость сопровождения кода.